@startuml

package "treeco.dialects.emitc" {

  class CExpression <<OpTrait>> { }

  class ArrayType <<ParametrizedAttribute, TypeAttribute, ShapedType, ContainerType>> {
    +shape: ArrayAttr[IntAttr]
    +element_type: Attribute
  }

  class OpaqueType <<ParametrizedAttribute, TypeAttribute>> {
    +value: StringAttr
  }

  class PointerType <<ParametrizedAttribute, TypeAttribute>> {
    +pointee: Attribute
  }

  class OpaqueAttr <<ParametrizedAttribute>> {
    +value: StringAttr
  }

  class Add <<IRDLOperation>> {
    +lhs
    +rhs
    +res
  }

  class Apply <<IRDLOperation>> {
    +operand
    +applicableOperator: StringAttr
    +result
  }

  class Conditional <<IRDLOperation>> {
    +condition
    +true_value
    +false_value
    +result
  }

  class Constant <<IRDLOperation>> {
    +value
    +result
  }

  class DeclareFunction <<IRDLOperation>> {
    +sym_name: StringAttr
  }

  class Div <<IRDLOperation>> {
    +divisor
    +dividend
    +result
  }

  class Assign <<IRDLOperation>> {
    +var
    +value
  }

  class CallOpaque <<IRDLOperation>> {
    +callee: StringAttr
    +args: ArrayAttr
    +"operands*"
    +"results*"
  }

  class Cast <<IRDLOperation>> {
    +operand
    +result
  }

  class Cmp <<IRDLOperation>> {
    +predicate: AnyIntegerAttr
    +lhs
    +rhs
    +result: Bool
  }

  class Variable <<IRDLOperation>> {
    +value
    +result
  }

  class Func <<IRDLOperation>> {
    +sym_name: StringAttr
    +function_type: FunctionType
    +"specifiers?: ArrayAttr[StringAttr]"
  }

  class GetGlobal <<IRDLOperation>> {
    +name: SymbolRefAttr
    +result
  }

  class Global <<IRDLOperation>> {
    +sym_name
    +type
    +initial_value
    +"extern?"
    +"static?"
    +"const?"
  }

  class If <<IRDLOperation>> {
    +condition
    +true_region
    +"false_region?"
  }

  class Include <<IRDLOperation>> {
    +include: StringAttr
    +"is_standard_include?"
  }

  class Literal <<IRDLOperation>> {
    +value
    +result
  }

  class LogicalAnd <<IRDLOperation>> {
    +lhs
    +rhs
    +result: Bool
  }

  class LogicalNot <<IRDLOperation>> {
    +operand
    +result: Bool
  }

  class LogicalOr <<IRDLOperation>> {
    +lhs
    +rhs
    +result: Bool
  }

  class Mul <<IRDLOperation>> {
    +lhs
    +rhs
    +result
  }

  class Rem <<IRDLOperation>> {
    +lhs
    +rhs
    +result
  }

  class Return <<IRDLOperation>> {
    +"operand*"
  }

  class Sub <<IRDLOperation>> {
    +lhs
    +rhs
    +result
  }

  class Subscript <<IRDLOperation>> {
    +value
    +"indices*"
    +result
  }

  class Verbatim <<IRDLOperation>> {
    +value: StringAttr
  }

  class Yield <<IRDLOperation>> { }

  class For <<IRDLOperation>> {
    +lowerBound
    +upperBound
    +step
    +body
  }

  ' Associations to attribute types
  CallOpaque ..> OpaqueAttr
  Include ..> StringAttr
  Func ..> FunctionType
  GetGlobal ..> SymbolRefAttr
  Global ..> TypeAttribute
  ArrayType ..> Attribute
  ArrayType ..> "shape: ArrayAttr[IntAttr]"
}

@enduml